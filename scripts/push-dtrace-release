#!/bin/bash
#
# push-dtrace-release --- Do release-pushing work.
#
#                         (C) 2011 Oracle Corporation.
#                         Licensed under GPLv2 (or any later version).
#

set -e
unset CDPATH

usage()
{
    cat >&2 <<EOF

Syntax:

push-dtrace-release {--module|--kernel} [-u username] [--old-release] \\
                    [--dtrace-dir-point SHA1] \\
                    release-branch master-branch upstream-branch
                    [remote-branch] [url]

Push a module or kernel release branch to a named git URL.

--module: Specify if this is a push of the CDDLed dtrace module.
--kernel: Specify if this is a push of the GPLed kernel plus GPLed dtrace bits.
-u username: Username on remote git server. Required if url is not specified.
--old-release: Specify if this is an old release, which should not update the
               'master' branch on the remote as well.
--dtrace-dir-point: If the branchpoint between the release and master branches
                     does not contain a split dtrace/ directory, this lets you
                     specify a point that does. It is unlikely to be necessary
                     except when pushing releases of very old dtraces,
                     predating the split.

release-branch: Name of the release branch
master-branch: Name of the master branch from which this release branch is
               derived
upstream-branch: Name of the upstream branch from which the DTrace kernel
                 is forked. (Used to isolate those commits that might
                 contain DTrace changes in the presence of repeated merges
                 from upstream.)

remote-branch: Name of the release branch in the remote repository (optional).
url: URL of the remote git repository to push to (optional, by default
     derived from --module or --kernel iff username is specified).

(If only one of remote-branch and url are provided, heuristic hacks are used
to work out which it is.  These heuristics prevent use of paths with colons
in them, and remote branch names starting with a slash, unless you specify
both remote-branch and url.)

EOF
    exit 1
}

get_dir_name()
{
    local tmpname;                  # A subdir name being tested for uniqueness

    false;                            # Starting state - reset $?
    while [[ $? -ne 0 ]]; do
        tmpname=${TMPDIR:-/tmp}/dtrace-release.${RANDOM}
        mkdir $tmpname                # Test-and-set it
    done

    echo $tmpname                     # Name is unique, return it
}

MODULE=
OLD_RELEASE=
USERNMAE=
DTRACE_DIR_POINT=

case "x$1" in
  x--module) MODULE=t;;
  x--kernel) MODULE=;;
  *) usage;;
esac
shift

while [[ "$#" -gt 0 ]]; do
    case "x$1" in
        x--old-release) OLD_RELEASE=t;;
        x--dtrace-dir-point) shift;
                             DTRACE_DIR_POINT=$1;;
        x-u) shift;
             USERNAME=$1;;
       *) break;;
    esac
    shift
done

if [[ $# -lt 3 ]] || [[ $# -gt 5 ]]; then
    usage
fi

RELEASE="$1"
MASTER="$2"
UPSTREAM="$3"
RBRANCH="$4"
URL="$5"

# Detect URL without remote branch.
if [[ -z $URL ]] && { [[ $RBRANCH =~ : ]] || [[ $RBRANCH =~ ^/ ]]; }; then
    URL="$RBRANCH"
    RBRANCH=
fi

# Default the URL.
if [[ -z $URL ]]; then
    if [[ -z $USERNAME ]]; then
        echo '-u <username> must be passed if URL is not specified.' >&2
        exit 1
    fi
    if [[ -z $MODULE ]]; then
        URL="ssh://$USERNAME@oss.oracle.com/home/sourcebo/git/linux-2.6-dtrace-unbreakable-beta.git"
    else
        URL="ssh://$USERNAME@oss.oracle.com/home/sourcebo/git/linux-2.6-dtrace-modules-beta.git"
    fi
fi

# Branch-name validation.
if [[ ! -e .git/refs/heads/$RELEASE ]]; then
    echo "Local branch $RELEASE does not exist." >&2
    exit 1
fi

if [[ ! -e .git/refs/heads/$MASTER ]]; then
    echo "Local branch $MASTER does not exist." >&2
    exit 1
fi

if [[ ! -e .git/refs/heads/$UPSTREAM ]]; then
    echo "Local branch $UPSTREAM does not exist." >&2
    exit 1
fi

if [[ -z $DTRACE_DIR_POINT ]]; then
    if ! git merge-base $RELEASE $MASTER >/dev/null 2>&1; then
        echo "Release branch $RELEASE and master branch $MASTER have no ancestry in common." >&2
        exit 1
    fi
fi

# Clone the tree into a new, temporary location, sharing objects
# with the original.
splitdir="$(get_dir_name)"
origdir=$(pwd)
git clone --shared $origdir --no-checkout $splitdir
cd $splitdir
git branch $RELEASE origin/$RELEASE
git checkout $RELEASE

# Kernel tree push. GPL.
if [[ -z $MODULE ]]; then

    # Check out the point at which the release branch split from the
    # development trunk: we assume that this point precedes any cleanup
    # deletions of broken CDDLed code.  (If not, you should use --dtrace-dir-point.)
    if [[ -z $DTRACE_DIR_POINT ]]; then
        git checkout $(git merge-base $RELEASE origin/$MASTER)
    else
        git checkout $DTRACE_DIR_POINT
    fi

    if [[ ! -d dtrace ]]; then
        echo "Error: master tree at point of release does not contain a " >&2
        echo "dtrace directory." >&2
        cd ..
        rm -rf $splitdir
        exit 1
    fi

    # Filter out CDDLed code from the release branch, erasing config-dtrace,
    # the dtrace directory, and all C or assembler files in the kernel/dtrace
    # directory which have names the same as files currently present in the
    # dtrace directory (thus eliminating the CDDL versions pre-GPL/CDDL
    # division).
    #
    # Because filtering the whole of history takes forever, only filter that
    # portion from the initial import onwards, where dtrace code may be
    # present.
    #
    # WARNING: changing this line will change history on oss.oracle.com,
    # and break everyone pulling from it without -f!
    git filter-branch --index-filter "git rm -r --cached --ignore-unmatch config-dtrace dtrace $(for name in $(git ls-files 'dtrace/*.[chS]'); do echo -n "kernel/$name "; done)" \
                      --tag-name-filter cat --prune-empty -- $(git describe ':/Initial import of DTrace kernelspace code')'^'..$RELEASE ^origin/$UPSTREAM

else # dtrace module push. CDDL.
    git filter-branch --tag-name-filter cat --subdirectory-filter dtrace $RELEASE
fi

# Erase all tags not reachable from the current commit.
comm -13 <(git log --decorate=full --simplify-by-decoration --pretty=oneline $RELEASE | \
           sed -r -e 's@^[^\(]*\(([^\)]*)\).*$@\1@' -e 's@,@\n@g' | \
           grep 'tag:' | sed -r -e 's@[[:space:]]*tag:[[:space:]]*@@' | sort -u) \
         <(git show-ref --tag | sed 's,^.*/,,' | sort -u) | \
    xargs git tag -d

# Now push content and all surviving tags.

git remote add oss-remote $URL
git push --force oss-remote $RELEASE${RBRANCH:+:}${RBRANCH:-} --tags

# Finally, if this is not an old release, erase then push the master branch.
# This will fail if the remote repository has receive.denyNonFastForwards set:
# the only fix is to unset it.

if [[ -z $OLD_RELEASE ]]; then
    git push --force oss-remote $RELEASE:refs/heads/master
fi

cd ..
rm -rf $splitdir
