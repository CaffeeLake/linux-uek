#!/bin/bash
#
# push-dtrace-release --- Do release-pushing work.
#
#                         (C) 2011 Oracle Corporation.
#                         Licensed under GPLv2 (or any later version).
#

set -e
unset CDPATH

usage()
{
    cat >&2 <<EOF

Syntax:

push-dtrace-release {--module|--kernel} [-u username] [--old-release] \\
                    release-branch master-branch [remote-branch] [url]

Push a module or kernel release branch to a named git URL.

--module: Specify if this is a push of the CDDLed dtrace module.
--kernel: Specify if this is a push of the GPLed kernel plus GPLed dtrace bits.
-u username: Username on remote git server. Required if url is not specified.
--old-release: Specify if this is an old release, which should not update the
               'master' branch on the remote as well.

release-branch: Name of the release branch
master-branch: Name of the master branch from which this release branch is
               derived
remote-branch: Name of the release branch in the remote repository (optional).
url: URL of the remote git repository to push to (optional, by default
     derived from --module or --kernel iff username is specified).

(If only one of remote-branch and url are provided, heuristic hacks are used
to work out which it is.  These heuristics prevent use of paths with colons
in them, and remote branch names starting with a slash, unless you specify
both remote-branch and url.)

EOF
    exit 1
}

get_dir_name()
{
    local tmpname;                  # A subdir name being tested for uniqueness

    false;                            # Starting state - reset $?
    while [[ $? -ne 0 ]]; do
        tmpname=${TMPDIR:-/tmp}/dtrace-release.${RANDOM}
        mkdir $tmpname                # Test-and-set it
    done

    echo $tmpname                     # Name is unique, return it
}

MODULE=
OLD_RELEASE=
USERNMAE=

case "x$1" in
  x--module) MODULE=t;;
  x--kernel) MODULE=;;
  *) usage;;
esac
shift

while [[ "$#" -gt 0 ]]; do
    case "x$1" in
        "x--old-release") OLD_RELEASE=t;;
        "x-u") shift;
               USERNAME=$1;;
       *) break;;
    esac
    shift
done

if [[ $# -lt 2 ]] || [[ $# -gt 4 ]]; then
    usage
fi

RELEASE="$1"
MASTER="$2"
RBRANCH="$3"
URL="$4"

# Detect URL without remote branch.
if [[ -z $URL ]] && { [[ $RBRANCH =~ : ]] || [[ $RBRANCH =~ ^/ ]]; }; then
    URL="$RBRANCH"
    RBRANCH=
fi

# Default the URL.
if [[ -z $URL ]]; then
    if [[ -z $USERNAME ]]; then
        echo '-u <username> must be passed if URL is not specified.' >&2
        exit 1
    fi
    if [[ -z $MODULE ]]; then
        URL="ssh://$USERNAME@oss.oracle.com/home/sourcebo/git/linux-2.6-dtrace-unbreakable-beta.git"
    else
        URL="ssh://$USERNAME@oss.oracle.com/home/sourcebo/git/linux-2.6-dtrace-modules-beta.git"
    fi
fi

# Branch-name validation.
if [[ ! -e .git/refs/heads/$RELEASE ]]; then
    echo "Local branch $RELEASE does not exist." >&2
    exit 1
fi

if [[ ! -e .git/refs/heads/$MASTER ]]; then
    echo "Local branch $MASTER does not exist." >&2
    exit 1
fi

if ! git merge-base $RELEASE $MASTER >/dev/null 2>&1; then
    echo "Release branch $RELEASE and master branch $MASTER have no ancestry in common." >&2
    exit 1
fi

# Clone the tree into a new, temporary location, sharing objects
# with the original.
splitdir="$(get_dir_name)"
origdir=$(pwd)
git clone --shared $origdir --no-checkout $splitdir
cd $splitdir
git branch $RELEASE origin/$RELEASE
git checkout $RELEASE

# Kernel tree push. GPL.
if [[ -z $MODULE ]]; then

    # Check out the point at which the release branch split from the
    # development trunk: we assume that this point precedes any cleanup
    # deletions of broken CDDLed code.
    git checkout $(git merge-base $RELEASE origin/$MASTER)

    if [[ ! -d dtrace ]]; then
        echo "Error: master tree at point of release does not contain a " >&2
        echo "dtrace directory." >&2
        cd ..
        rm -rf $splitdir
        exit 1
    fi

    # Filter out CDDLed code from the release branch, erasing config-dtrace,
    # the dtrace directory, and all C or assembler files in the kernel/dtrace
    # directory which have names the same as files currently present in the
    # dtrace directory (thus eliminating the CDDL versions pre-GPL/CDDL
    # division).
    #
    # Because filtering the whole of history takes forever, only filter that
    # portion from the initial import onwards, where dtrace code may be
    # present.
    #
    # WARNING: changing this line will change history on oss.oracle.com,
    # and break everyone pulling from it without -f!
    git filter-branch --index-filter "git rm -r --cached --ignore-unmatch config-dtrace dtrace $(for name in $(git ls-files 'dtrace/*.[chS]'); do echo -n "kernel/$name "; done)" \
                      --tag-name-filter cat --prune-empty -- $(git describe ':/Initial import of DTrace kernelspace code')'^'..$RELEASE

    # Prune tags we don't want. The kernel loses only the junk CVS-conversion
    # tags and the userspace tags.
    git show-ref --tag | grep -E 'refs/tags/(INITIAL|dtrace-base|dtrace-user-.*|latest-cvs)$' | \
        sed 's,^.*refs/tags/,,' | xargs git tag -d

else # dtrace module push. CDDL.
    git filter-branch --tag-name-filter cat --subdirectory-filter dtrace $RELEASE

    # Prune tags we don't want. The module loses the junk CVS-conversion
    # tags, the userspace tags, Linus's tags, and a dtrace release tag
    # from before the CDDL/GPL split.
    #
    # WARNING: changing this line will change history on oss.oracle.com,
    # and break everyone pulling from it without -f!
    git show-ref --tag | grep -E 'refs/tags/(INITIAL|dtrace-base|dtrace-user-.*|latest-cvs|dtrace-kernel-0.1-20111005|v[0-9].*)$' | \
        sed 's,^.*refs/tags/,,' | xargs git tag -d
fi

# Now push content and all surviving tags.

git remote add oss-remote $URL
git push oss-remote $RELEASE${RBRANCH:+:}${RBRANCH:-} --tags

# Finally, if this is not an old release, push the master branch.

if [[ -z $OLD_RELEASE ]]; then
    git push --force oss-remote $RELEASE:refs/heads/master
fi

cd ..
rm -rf $splitdir
